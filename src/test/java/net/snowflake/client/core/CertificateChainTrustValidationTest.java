package net.snowflake.client.core;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import java.io.InputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

/**
 * This test validates the behavior of the SFTrustManager (which should use PKIX validation)
 * when validating a specific cross-signed certificate chain.
 * It also compares this with the behavior of the SunX509 X509TrustManager
 * The test ensures that:
 * - The SFTrustManager can validate the chain successfully.
 * - The SunX509 X509TrustManager fails validation due to its trust store configuration.
 *
 * Prerequisites for this test:
 * - The certificates used in this test must be generated by the script located at ssl-tests/generate_certs.sh
 * - The test should be run with following JVM options:
 * -Djavax.net.ssl.trustStore=path/to/test/resources/ssl-tests/certs/truststore.jks
 * -Djavax.net.ssl.trustStorePassword=changeit
 */
public class CertificateChainTrustValidationTest {

    private static final String CERT_RESOURCE_PATH = "ssl-tests/certs/";
    private static final String TRUST_STORE_FILE_NAME = "truststore.jks";
    private static final String TRUST_STORE_PASSWORD = "changeit";

    // Certificates for the exact chain generated by the script
    private static X509Certificate snowflakeLeafCert;                 // Cert 0
    private static X509Certificate amazonRsaM02IntermediateCert;      // Cert 1
    private static X509Certificate amazonRootCa1ChainCert;            // Cert 2 (issued by Starfield G2)
    private static X509Certificate starfieldG2RootCert;               // Cert 3 (issued by Starfield Class 2)
    private static X509Certificate starfieldClass2RootCert;           // Ultimate Root of the chain (self-signed)

    // The specific self-signed Amazon Root CA 1 from the trust store
    private static X509Certificate amazonRootCa1SelfSignedForTrustStoreCert;

    private static SFTrustManager sfTrustManager;
    private static X509TrustManager sunX509TrustManager;

    @BeforeAll
    static void setUpAll() throws Exception {
        System.out.println("--- Test Setup Started ---");
        System.out.println("Verifying chain certificates exist in resources...");
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + "snowflake_leaf.crt")) {
            if (is == null) {
                throw new IllegalStateException("Snowflake Leaf certificate not found in resources. " +
                        "Please ensure the './recreate_all_certs.sh' script was run successfully from your project root.");
            }
        } catch (IOException e) {
            throw new IllegalStateException("Error accessing test resources: " + e.getMessage(), e);
        }

        CertificateFactory cf = CertificateFactory.getInstance("X.509");

        System.out.println("Loading chain certificates from classpath: " + CERT_RESOURCE_PATH + "...");
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + "snowflake_leaf.crt")) {
            snowflakeLeafCert = (X509Certificate) cf.generateCertificate(is);
        }
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + "amazon_rsa_m02_intermediate.crt")) {
            amazonRsaM02IntermediateCert = (X509Certificate) cf.generateCertificate(is);
        }
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + "amazon_root_ca1_chain.crt")) {
            amazonRootCa1ChainCert = (X509Certificate) cf.generateCertificate(is);
        }
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + "starfield_g2_root.crt")) {
            starfieldG2RootCert = (X509Certificate) cf.generateCertificate(is);
        }
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + "starfield_class2_root.crt")) {
            starfieldClass2RootCert = (X509Certificate) cf.generateCertificate(is);
        }
        System.out.println("Chain certificates loaded successfully.");

        System.out.println("Loading the specific self-signed Amazon Root CA 1 for the trust store...");
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + "amazon_root_ca1_trust_store.crt")) {
            amazonRootCa1SelfSignedForTrustStoreCert = (X509Certificate) cf.generateCertificate(is);
        }
        System.out.println("Self-signed Amazon Root CA 1 for Trust Store loaded.");

        System.out.println("Loading trust store from classpath: " + CERT_RESOURCE_PATH + TRUST_STORE_FILE_NAME + "...");
        KeyStore trustStore = KeyStore.getInstance("JKS");
        try (InputStream is = getResourceStream(CERT_RESOURCE_PATH + TRUST_STORE_FILE_NAME)) {
            trustStore.load(is, TRUST_STORE_PASSWORD.toCharArray());
        }
        System.out.println("Trust store loaded.");

        assertTrue(trustStore.containsAlias("amazonrootca1_self_signed_for_ts"), "Trust store MUST contain 'amazonrootca1_self_signed_for_ts' alias.");
        System.out.println("Trust store content verified: only amazon_root_ca1_self_signed_for_ts is present as a trust anchor.");

        System.out.println("Initializing PKIX X509TrustManager...");
        sfTrustManager = new SFTrustManager(new HttpClientSettingsKey(OCSPMode.FAIL_CLOSED), null);
        assertNotNull(sfTrustManager, "PKIX X509TrustManager should be initialized.");
        System.out.println("PKIX X509TrustManager initialized successfully.");

        System.out.println("Initializing SunX509 X509TrustManager...");
        TrustManagerFactory sunX509Tmf = TrustManagerFactory.getInstance("SunX509");
        sunX509Tmf.init(trustStore);
        for (TrustManager tm : sunX509Tmf.getTrustManagers()) {
            if (tm instanceof X509TrustManager) {
                sunX509TrustManager = (X509TrustManager) tm;
                break;
            }
        }
        assertNotNull(sunX509TrustManager, "SunX509 X509TrustManager should be initialized.");
        System.out.println("SunX509 X509TrustManager initialized successfully.");

        System.out.println("--- Test Setup Complete ---");
    }

    private static InputStream getResourceStream(String resourceName) {
        InputStream is = CertificateChainTrustValidationTest.class.getClassLoader().getResourceAsStream(resourceName);
        if (is == null) {
            System.err.println("ERROR: Resource not found: " + resourceName + ". Ensure 'recreate_all_certs.sh' placed it correctly.");
        }
        return is;
    }

    /**
     * Scenario:
     * - Chain: Snowflake Leaf -> Amazon RSA 2048 M02 -> Amazon Root CA 1 (issued by Starfield G2) -> Starfield G2 (issued by Starfield Class 2)
     * - Trust Store: Contains ONLY a *self-signed* Amazon Root CA 1 (which shares Subject DN and Public Key with the chain's Amazon Root CA 1).
     */
    @Test
    void shouldProperlyValidateCrossSignedChain() {
        // The chain provided will be the full 4-certificate chain.
        // PKIX should find the trusted public key at amazonRootCa1ChainCert and terminate successfully there.
        X509Certificate[] chain = new X509Certificate[]{
                snowflakeLeafCert,
                amazonRsaM02IntermediateCert,
                amazonRootCa1ChainCert,   // This is the Amazon Root CA 1 issued by Starfield G2.
                starfieldG2RootCert       // This is Starfield G2, its issuer.
        };
        String authType = "RSA";

        // Test with SfTrustManager (PKIX Validation)
        assertDoesNotThrow(() -> {
            sfTrustManager.checkServerTrusted(chain, authType);
        }, "PKIX should pass because the chain's Amazon Root CA 1 public key matches a trusted anchor.");

        // Test with SunX509 Validation
        Exception e = assertThrows(Exception.class, () -> sunX509TrustManager.checkServerTrusted(chain, authType));
        assertTrue(e.getMessage().contains("No trusted certificate found"),
                "SunX509 should fail because it does match Amazon Root CA 1 as a trusted anchor in the trust store, " +
                "even though the public key matches. This is expected behavior for SunX509.");
    }
}